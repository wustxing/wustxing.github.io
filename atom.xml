<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wustxing</title>
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ypintao.com/"/>
  <updated>2017-03-24T14:10:29.301Z</updated>
  <id>http://blog.ypintao.com/</id>
  
  <author>
    <name>wustxing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pomelo并非完全的游戏引擎</title>
    <link href="http://blog.ypintao.com/2017/03/24/%E6%8A%80%E6%9C%AF/%E6%A1%86%E6%9E%B6demo/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6pomelo/"/>
    <id>http://blog.ypintao.com/2017/03/24/技术/框架demo/游戏框架pomelo/</id>
    <published>2017-03-23T16:00:00.000Z</published>
    <updated>2017-03-24T14:10:29.301Z</updated>
    
    <content type="html"><![CDATA[<p>前几天有个朋友问，棋牌游戏js可以做不，由于对于游戏这一块基本算是空白，所以就稍微查了下资料，不想，有新的发现。<br>大名鼎鼎的pomelo 大家应该不陌生。<br>没想到他的文档还挺齐全的，它是基于nodejs的，下面介绍下pomelo的安装</p>
<ul>
<li><h4 id="Pomelo的设计动机"><a href="#Pomelo的设计动机" class="headerlink" title="Pomelo的设计动机"></a>Pomelo的设计动机</h4></li>
</ul>
<p>pomelo最初的设计初衷是为了游戏服务器， 不过在设计、开发完成后发现pomelo是个通用的分布式实时应用开发框架。下面将结合实际，从游戏服务器的需求，以及开发中面临的问题等方面阐述pomelo的设计动机。<a id="more"></a></p>
<ul>
<li><h4 id="游戏服务器概述"><a href="#游戏服务器概述" class="headerlink" title="游戏服务器概述"></a>游戏服务器概述</h4>没开发过游戏的人会觉得游戏服务器是很神秘的东西。但事实上它并不比web服务器复杂，无非是给客户端提供网络请求服务，本质上它只是基于长连接的socket服务器。当然在逻辑复杂性、消息量、实时性方面有更高的要求，下面从web服务器与游戏服务器的对比中来说明游戏服务器的一些特点：</li>
</ul>
<p>复杂的socket服务器</p>
<p>如果说web服务器的本质是http服务器，那么游戏服务器的本质就是socket服务器。 它利用socket通讯来实现服务器与客户端之间的交互。事实上有不少游戏是直接基于原生socket来开发的。 相对于简单的socket服务器，它承受着更加繁重的任务：</p>
<p>后端承载着极复杂的游戏逻辑。<br>网络流量与消息量巨大，且实时性要求高。<br>通常一台socket服务器无法支撑复杂的游戏逻辑，因此往往使用一个服务器集群来提供服务。<br>长连接和实时响应</p>
<p>web应用都是基于request/response的短连接模式,占用的资源要比一直hold长连接的游戏服务器要少很多，因此web应用可以使用基于http的短连接来达到最大的可扩展性，Web应用能使用短连接模式的原因如下：</p>
<p>通讯的单向性，普通web应用一般只有拉模式<br>响应的实时性要求不高，一般web应用的响应时间在3秒以内都算响应比较及时的。<br>而游戏应用只能使用长连接，原因如下：</p>
<p>通讯的双向性，游戏应用不仅仅是推拉模式，而且推送的数据量要远远大于拉的数据量<br>响应的实时性要求极高，一般游戏应用要求推送的消息实时反应，而实时响应的最大时间是100ms。<br>分区策略与负载均衡</p>
<p>普通的web应用在交互上没有相邻性的概念，所有用户之间的交互都是平等，交互频率也不受地域限制。 而游戏则不然，游戏交互跟玩家所在地图（场景）上的位置关系非常大，如两个玩家在相邻的地方可以互相PK或组队打怪。这种相邻的交互频率非常高，对实时性的要求也非常高，这就必须要求相邻玩家在分布在同一个进程里。于是就有了按场景分区的策略，如图所示：</p>
<p><img src="https://github.com/NetEase/pomelo/wiki/images/processArea.png" alt=""></p>
<p>一个进程里可以有一个场景，也可以有多个场景。这种实现带来了游戏的可伸缩性受到场景进程的限制，如果某个场景过于烦忙可能会把进程撑爆，也就把整个游戏撑爆。场景服务器是有状态的，每个用户请求必须发回原来的场景服务器。服务器的有状态带来一系列的问题：场景进程的可伸缩，高可用性等都比不上web服务器。目前只能通过游戏服务器的隔离来缓解这些问题。</p>
<p>web应用的分区可以根据负载均衡自由决定， 而游戏则是基于场景(area)的分区模式， 这使同场景的玩家跑在一个进程内， 以达到最少的跨进程调用。</p>
<p>可伸缩性与分布式开发</p>
<p>不管是web应用还是游戏服务器，可伸缩性始终是最重要的指标，也是最棘手的问题，它涉及到系统运行架构的搭建，各种优化策略。 只有把可伸缩性设计好了，游戏的规模、同时在线人数、响应时间等参数才能得到保证。最初的网络服务器是单进程的架构，所有的逻辑都在单台服务器内完成， 这对于同时在线要求不高的游戏是可以这么做的。由于同时在线人数的上升， 单服务器的可伸缩性必然受到挑战。随着网络游戏对可伸缩性要求的增加，分布式是必然的趋势的。 下面是一个web服务器和游戏服务器架构对比的示意图：</p>
<p><img src="https://github.com/NetEase/pomelo/wiki/images/webGameComp.png" alt="1"></p>
<p>可以看到由于web服务器的无状态性，只需要通过前端的负载均衡器可以导向任意一个进程，因此运行架构相对简单， 而且很少需要分布式开发。</p>
<p>而游戏服务器是蜘蛛网式的架构，每个进程都有各自的职责，这些进程的交织在一起共同完成一件任务。因此游戏服务器是一个标准的分布式开发架构。</p>
<ul>
<li><h4 id="pomelo的定位"><a href="#pomelo的定位" class="headerlink" title="pomelo的定位"></a>pomelo的定位</h4></li>
</ul>
<p>pomelo是一个轻量级的服务器框架，它最适合的应用领域是网页游戏、社交游戏、移动游戏的服务端，开发者会发现pomelo可以用如此少的代码达到强大的扩展性和伸缩性。当然还不仅仅是游戏，用pomelo开发高实时web应用也如此合适， 而且伸缩性比其它框架好。</p>
<p>不推荐将pomelo用于大型的MMORPG游戏开发，尤其是大型3D游戏， 还是需要象Bigworld这样的商用引擎来支撑。</p>
<ul>
<li><p>####安装条件<br>1、确保机器能够上网。<br>2、需要安装node，python2.5以上，以及c++的编译器。</p>
<ul>
<li>python(2.5&lt;version&lt;3.0)。</li>
<li>VC++ 编译器，包含在Visual Studio 2010中（VC++ 2010 Express亦可）。对于windows8的用户，需要安装Microsoft Visual Studio C++ 2012。</li>
</ul>
</li>
<li><p>####开始安装</p>
</li>
</ul>
<blockquote>
<p>npm install pomelo -g</p>
</blockquote>
<p>windows下安装一定用注意python的环境变量配置</p>
<ol>
<li>node,vs2010 和 python(2.5&lt;v&lt;3) 都是32位或者都是64位的。</li>
<li>配置  PYTHON=d:\Python27\python.exe(设置成你自己的路径)。注意不是path里面,而是和path同级的，直接在全局或者当前用户下配置。</li>
<li>保证环境变量path里面有 %SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;<br>注： 这三个环境变量中貌似只有%SystemRoot%\system32这个环境变量有用，没具体试（没有他会报CreateProcessW找不到的错误)。</li>
<li>如果在命令行界面安装pomelo失败，可以在Visual Studio的命令行界面安装。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天有个朋友问，棋牌游戏js可以做不，由于对于游戏这一块基本算是空白，所以就稍微查了下资料，不想，有新的发现。&lt;br&gt;大名鼎鼎的pomelo 大家应该不陌生。&lt;br&gt;没想到他的文档还挺齐全的，它是基于nodejs的，下面介绍下pomelo的安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Pomelo的设计动机&quot;&gt;&lt;a href=&quot;#Pomelo的设计动机&quot; class=&quot;headerlink&quot; title=&quot;Pomelo的设计动机&quot;&gt;&lt;/a&gt;Pomelo的设计动机&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pomelo最初的设计初衷是为了游戏服务器， 不过在设计、开发完成后发现pomelo是个通用的分布式实时应用开发框架。下面将结合实际，从游戏服务器的需求，以及开发中面临的问题等方面阐述pomelo的设计动机。
    
    </summary>
    
      <category term="demo" scheme="http://blog.ypintao.com/categories/demo/"/>
    
    
      <category term="demo" scheme="http://blog.ypintao.com/tags/demo/"/>
    
  </entry>
  
  <entry>
    <title>二维码活码生成原理</title>
    <link href="http://blog.ypintao.com/2017/03/23/%E6%8A%80%E6%9C%AF/IDEA/%E6%B4%BB%E7%A0%81%E7%94%9F%E6%88%90%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.ypintao.com/2017/03/23/技术/IDEA/活码生成实现/</id>
    <published>2017-03-22T16:00:00.000Z</published>
    <updated>2017-03-23T12:38:34.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二维码分类"><a href="#二维码分类" class="headerlink" title="二维码分类"></a>二维码分类</h3><p>二维码分类这里就直接套用草根二维码的原话了，总结的非常好。</p>
<h5 id="什么是二维码、静态码、活码？"><a href="#什么是二维码、静态码、活码？" class="headerlink" title="什么是二维码、静态码、活码？"></a>什么是二维码、静态码、活码？</h5><ul>
<li><strong>静态码</strong>：是直接对电话、地址、网址等信息进行编码（一般最多50个文字）， 所以无需联网也能扫描显示，缺点是生成的二维码图案非常复杂，不容易识别和打印，容错率低；而且印刷后内容无法变更，无法存储图片和文件。</li>
<li><strong>活码</strong>：是对一个分配的短网址进行编码，扫描后跳转到这个网址。这样将内容存储在云端，可以随时更新、可跟踪扫描统计，可存放图片视频、大量文字内容，同时图案简单易扫。 草料活码永久免费面向用户开放。草料经过近三年的积累，开发了活码管理系统，实现了活码的在线修改、后台管理等功能。<a id="more"></a></li>
</ul>
<h3 id="链接转二维码"><a href="#链接转二维码" class="headerlink" title="链接转二维码"></a>链接转二维码</h3><p>基于jquery-qrcode很好实现一个链接转二维码的例子，在这里就不过多讲解了。</p>
<h3 id="链接转活码"><a href="#链接转活码" class="headerlink" title="链接转活码"></a>链接转活码</h3><p><strong>链接转活码</strong>，采用 链接A—-&gt;生成guid并将链接和guid存储到数据库——&gt;生成一个服务器端的api的带有guid参数的二维码图片，这样不管多长的链接都能生成一个固定的短码图片了。</p>
<p>当用户扫描二维码的时候，访问的是服务器端api带有参数的的二维码，这个api获取参数以后去查询，找到之前生成的链接，然后重定向跳转到相应的链接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二维码分类&quot;&gt;&lt;a href=&quot;#二维码分类&quot; class=&quot;headerlink&quot; title=&quot;二维码分类&quot;&gt;&lt;/a&gt;二维码分类&lt;/h3&gt;&lt;p&gt;二维码分类这里就直接套用草根二维码的原话了，总结的非常好。&lt;/p&gt;
&lt;h5 id=&quot;什么是二维码、静态码、活码？&quot;&gt;&lt;a href=&quot;#什么是二维码、静态码、活码？&quot; class=&quot;headerlink&quot; title=&quot;什么是二维码、静态码、活码？&quot;&gt;&lt;/a&gt;什么是二维码、静态码、活码？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态码&lt;/strong&gt;：是直接对电话、地址、网址等信息进行编码（一般最多50个文字）， 所以无需联网也能扫描显示，缺点是生成的二维码图案非常复杂，不容易识别和打印，容错率低；而且印刷后内容无法变更，无法存储图片和文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;活码&lt;/strong&gt;：是对一个分配的短网址进行编码，扫描后跳转到这个网址。这样将内容存储在云端，可以随时更新、可跟踪扫描统计，可存放图片视频、大量文字内容，同时图案简单易扫。 草料活码永久免费面向用户开放。草料经过近三年的积累，开发了活码管理系统，实现了活码的在线修改、后台管理等功能。
    
    </summary>
    
      <category term="IDEA" scheme="http://blog.ypintao.com/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://blog.ypintao.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>小总结</title>
    <link href="http://blog.ypintao.com/2017/03/21/%E9%9A%8F%E7%AC%94/%E5%8D%9A%E5%AE%A2%E4%BB%8E%E6%96%B0%E8%B5%B7%E8%88%AA/"/>
    <id>http://blog.ypintao.com/2017/03/21/随笔/博客从新起航/</id>
    <published>2017-03-20T16:00:00.000Z</published>
    <updated>2017-03-22T06:06:59.258Z</updated>
    
    <content type="html"><![CDATA[<p>最近家里一直断网来着，然后刚好在找工作，就写个总结，然后分个类别，把自己掌握的一些个东西写出来。所以有了这个，嘿嘿。其实，觉得有些东西还是记下来靠谱，至少学习得留下一些印记吧，不知不觉毕业5年了，在这5年里，技术的广度算是摸的差不多了，就像很多公司跻身于这大大互联网一样，我跻身于这浩浩荡荡的程序员的世界，写过桌面应用，做过paas平台，倒腾过数据库，慢慢的也算是见过一些场面了。<a id="more"></a></p>
<p>其实写下这篇文章的目的是为了先给自己总结下，然后分个类别。以后玩东西的时候也好往相应的类别下面丢东西。<br>目前熟练使用的东西大概有：</p>
<h3 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h3><pre><code>.Net MVC
Node Express
</code></pre><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><pre><code>angularjs
ionic
WPF
winform
</code></pre><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><pre><code>gulp
requirejs
</code></pre><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><pre><code>jenkins
</code></pre><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><pre><code>git
</code></pre><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><pre><code>mysql
sqlserver
mongodb
</code></pre><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><pre><code>windos
linux
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近家里一直断网来着，然后刚好在找工作，就写个总结，然后分个类别，把自己掌握的一些个东西写出来。所以有了这个，嘿嘿。其实，觉得有些东西还是记下来靠谱，至少学习得留下一些印记吧，不知不觉毕业5年了，在这5年里，技术的广度算是摸的差不多了，就像很多公司跻身于这大大互联网一样，我跻身于这浩浩荡荡的程序员的世界，写过桌面应用，做过paas平台，倒腾过数据库，慢慢的也算是见过一些场面了。
    
    </summary>
    
      <category term="随笔" scheme="http://blog.ypintao.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="文章" scheme="http://blog.ypintao.com/categories/%E9%9A%8F%E7%AC%94/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="心情" scheme="http://blog.ypintao.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>关于正则</title>
    <link href="http://blog.ypintao.com/2016/08/04/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/JS/%E5%85%B3%E4%BA%8E%E6%AD%A3%E5%88%99/"/>
    <id>http://blog.ypintao.com/2016/08/04/技术/web前端/JS/关于正则/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2017-03-22T06:56:58.963Z</updated>
    
    <content type="html"><![CDATA[<p>在这里我不统一讲解正则的具体用法<br>就讲解我们平常用的一些知识</p>
<ul>
<li>^ 匹配开始、</li>
<li>$匹配结束、</li>
<li><ul>
<li>匹配1个或多个、</li>
</ul>
</li>
<li>? 匹配0个或一个、</li>
<li>*匹配0个或多个、</li>
<li>g全局匹配、</li>
<li>\d 匹配所有数字、</li>
<li>\w 匹配所有字符、</li>
<li>\s 匹配所有空格<a id="more"></a></li>
</ul>
<p>用正则写出trim函数<br>trim函数主要是去除头尾空格<br>str.replace(/^\s|\s$/g,””);</p>
<p>邮箱匹配</p>
<ul>
<li>/^\w*@\w{2,3}.[com|cn]/</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这里我不统一讲解正则的具体用法&lt;br&gt;就讲解我们平常用的一些知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;^ 匹配开始、&lt;/li&gt;
&lt;li&gt;$匹配结束、&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;匹配1个或多个、&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;? 匹配0个或一个、&lt;/li&gt;
&lt;li&gt;*匹配0个或多个、&lt;/li&gt;
&lt;li&gt;g全局匹配、&lt;/li&gt;
&lt;li&gt;\d 匹配所有数字、&lt;/li&gt;
&lt;li&gt;\w 匹配所有字符、&lt;/li&gt;
&lt;li&gt;\s 匹配所有空格
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="JS" scheme="http://blog.ypintao.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>关于前端漏洞</title>
    <link href="http://blog.ypintao.com/2016/07/11/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/JS/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://blog.ypintao.com/2016/07/11/技术/web前端/JS/关于前端漏洞/</id>
    <published>2016-07-10T16:00:00.000Z</published>
    <updated>2017-03-22T07:09:16.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xss，csrf（Cross-site-request-forgery）跨站点请求伪造"><a href="#xss，csrf（Cross-site-request-forgery）跨站点请求伪造" class="headerlink" title="xss，csrf（Cross-site request forgery）跨站点请求伪造"></a>xss，csrf（Cross-site request forgery）跨站点请求伪造</h2><p>####xss :  xss就是在页面执行你想要的js</p>
<h5 id="XSS-防御技巧"><a href="#XSS-防御技巧" class="headerlink" title="XSS 防御技巧"></a>XSS 防御技巧</h5><p>XSS 防御技巧</p>
<p>HttpOnly</p>
<p>服务器端在设置安全级别高的Cookie时，带上HttpOnly的属性，就能防止JavaScript获取。<a id="more"></a><br>PHP设置HttpOnly：<br>1 &lt;?2 header(“Set-Cookie: a=1;”, false);3 header(“Set-Cookie: b=1;httponly”, false);4 setcookie(“c”, “1”, NULL, NULL, NULL, NULL, ture);</p>
<p>输入检查</p>
<p>任何用户输入的数据，都是“不可信”的。<br>输入检查，一般是用于输入格式检查，例如：邮箱、电话号码、用户名这些…<br>都要按照规定的格式输入：电话号码必须纯是数字和规定长度；用户名除 中英文数字 外，仅允许输入几个安全的符号。<br>输入过滤不能完全交由前端负责，前端的输入过滤只是为了避免普通用户的错误输入，减轻服务器的负担。<br>因为攻击者完全可以绕过正常输入流程，直接利用相关接口向服务器发送设置。<br>所以，前端和后端要做相同的过滤检查。</p>
<p>输出检查</p>
<p>相比输入检查，前端更适合做输出检查。<br>可以看到，HttpOnly和前端没直接关系，输入检查的关键点也不在于前端。<br>那XSS的防御就和前端没关系了?<br>当然不是，随着移动端web开发发展起来了，Ajax的使用越来越普遍，越来越多的操作都交给前端来处理。<br>前端也需要做好XSS防御。<br>JavaScript直接通过Ajax向服务器请求数据，接口把数据以JSON格式返回。前端整合处理数据后，输出页面。<br>所以，前端的XSS防御点，在于输出检查。</p>
<p>但也要结合XSS可能发生的场景。</p>
<p>XSS注意场景</p>
<p>在HTML标签中输出<br>如：{$var}<br>风险：{$var} 为 <img src="#" onerror="/xss/"><br>防御手段：变量HtmlEncode后输出</p>
<p>在HTML属性中输出<br>如：<div data-num="{$var}"></div><br>风险：{$var} 为 “ onclick=”/xss/<br>防御手段：变量HtmlEncode后输出</p>
<p>在<script>标签中输出<br>如：<script>var num = {$var};</script><br>风险：{$var} 为 1; alert(/xss/)<br>防御手段：确保输出变量在引号里面，再让变量JavaScriptEncode后输出。</p>
<p>在事件中输出<br>如：<span onclick="fun({$var})">hello!click me!</span><br>风险：{$var} 为 ); alert(/xss/); //<br>防御手段：确保输出变量在引号里面，再让变量JavaScriptEncode后输出。</p>
<p>在CSS中输出<br>一般来说，尽量禁止用户可控制的变量在<style>标签和style属性中输出。</p>
<p>#####HtmlEncode</p>
<p>对下列字符实现编码</p>
<ul>
<li>&amp; ——》 &amp;</li>
<li>&lt; ——》 &lt;</li>
<li>——》 &gt;</li>
<li>“ ——》 “</li>
<li>‘ ——》 ‘ （IE不支持’）</li>
<li>/ ——》 /</li>
</ul>
<p>######JavaScriptEncode</p>
<p>对下列字符加上反斜杠</p>
<ul>
<li>“ ——》 \”</li>
<li>‘ ——》 \’</li>
<li>\ ——》 \</li>
<li>\n ——》 \n</li>
<li>\r ——》 \r (Windows下的换行符)</li>
</ul>
<p>例子： “\”.replace(/\/g, “\“); //return \<br>URLEncode<br>使用以下JS原生方法进行URI编码和解码：<br>encodeURI<br>decodeURI<br>decodeURIComponent<br>encodeURIComponent</p>
<h4 id="CSRF（Cross-site-request-forgery）"><a href="#CSRF（Cross-site-request-forgery）" class="headerlink" title="CSRF（Cross-site request forgery）"></a>CSRF（Cross-site request forgery）</h4><p>CSRF 即：跨站点请求伪造<br>网站A ：为恶意网站。<br>网站B ：用户已登录的网站。<br>当用户访问 A站 时，A站 私自访问 B站 的操作链接，模拟用户操作。<br>假设B站有一个删除评论的链接：<a href="http://b.com/comment/?type=delete&amp;id=81723">http://b.com/comment/?type=delete&amp;id=81723</a><br>A站 直接访问该链接，就能删除用户在 B站 的评论。</p>
<p>CSRF 的攻击策略</p>
<p>因为浏览器访问 B站 相关链接时，会向其服务器发送 B站 保存在本地的Cookie，以判断用户是否登陆。所以通过 A站 访问的链接，也能顺利执行。</p>
<h4 id="CSRF-防御技巧"><a href="#CSRF-防御技巧" class="headerlink" title="CSRF 防御技巧"></a>CSRF 防御技巧</h4><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>几乎所有人都知道验证码，但验证码不单单用来防止注册机的暴力破解，还可以有效防止CSRF的攻击。<br>验证码算是对抗CSRF攻击最简洁有效的方法。<br>但使用验证码的问题在于，不可能在用户的所有操作上都需要输入验证码。<br>只有一些关键的操作，才能要求输入验证码。<br>不过随着HTML5的发展。<br>利用canvas标签，前端也能识别验证码的字符，让CSRF生效。</p>
<h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h5><p>Referer Check即来源检测。<br>HTTP Referer 是 Request Headers 的一部分，当浏览器向web服务器发出请求的时候，一般会带上Referer，告诉服务器用户从哪个站点链接过来的。<br>服务器通过判断请求头中的referer，也能避免CSRF的攻击。</p>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>CSRF能攻击成功，根本原因是：操作所带的参数均被攻击者猜测到。<br>既然知道根本原因，我们就对症下药，利用Token。<br>当向服务器传参数时，带上Token。这个Token是一个随机值，并且由服务器和用户同时持有。<br>Token可以存放在用户浏览器的Cookie中，<br>当用户提交表单时带上Token值，服务器就能验证表单和Cookie中的Token是否一致。<br>（前提，网站没有XSS漏洞，攻击者不能通过脚本获取用户的Cookie）</p>
</style></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;xss，csrf（Cross-site-request-forgery）跨站点请求伪造&quot;&gt;&lt;a href=&quot;#xss，csrf（Cross-site-request-forgery）跨站点请求伪造&quot; class=&quot;headerlink&quot; title=&quot;xss，csrf（Cross-site request forgery）跨站点请求伪造&quot;&gt;&lt;/a&gt;xss，csrf（Cross-site request forgery）跨站点请求伪造&lt;/h2&gt;&lt;p&gt;####xss :  xss就是在页面执行你想要的js&lt;/p&gt;
&lt;h5 id=&quot;XSS-防御技巧&quot;&gt;&lt;a href=&quot;#XSS-防御技巧&quot; class=&quot;headerlink&quot; title=&quot;XSS 防御技巧&quot;&gt;&lt;/a&gt;XSS 防御技巧&lt;/h5&gt;&lt;p&gt;XSS 防御技巧&lt;/p&gt;
&lt;p&gt;HttpOnly&lt;/p&gt;
&lt;p&gt;服务器端在设置安全级别高的Cookie时，带上HttpOnly的属性，就能防止JavaScript获取。
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="JS" scheme="http://blog.ypintao.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS问题汇总</title>
    <link href="http://blog.ypintao.com/2016/07/01/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/JS/JS%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ypintao.com/2016/07/01/技术/web前端/JS/JS问题汇总/</id>
    <published>2016-06-30T16:00:00.000Z</published>
    <updated>2017-03-22T06:57:06.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、如何解决跨域问题"><a href="#1、如何解决跨域问题" class="headerlink" title="1、如何解决跨域问题"></a>1、如何解决跨域问题</h3><p>  nginx代理，或后端设置，</p>
<h3 id="2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）"><a href="#2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）" class="headerlink" title="2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）"></a>2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）</h3><a id="more"></a>
<h3 id="3、异步加载的方式有哪些"><a href="#3、异步加载的方式有哪些" class="headerlink" title="3、异步加载的方式有哪些"></a>3、异步加载的方式有哪些</h3><ul>
<li>1、js动态加载dom元素</li>
<li>2、onload异步加载</li>
<li>3、使用requerjs这种，是属于异步加载。</li>
</ul>
<h3 id="4、javascript原型，原型链，？有什么特点？"><a href="#4、javascript原型，原型链，？有什么特点？" class="headerlink" title="4、javascript原型，原型链，？有什么特点？"></a>4、javascript原型，原型链，？有什么特点？</h3><p>*每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br>关系：instance.constructor.prototype = instance.__proto<em>\</em></p>
<h3 id="5、Javascript作用链域"><a href="#5、Javascript作用链域" class="headerlink" title="5、Javascript作用链域?"></a>5、Javascript作用链域?</h3><ul>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</li>
</ul>
<h3 id="6、用原生javascript的实现过说明功能。"><a href="#6、用原生javascript的实现过说明功能。" class="headerlink" title="6、用原生javascript的实现过说明功能。"></a>6、用原生javascript的实现过说明功能。</h3><ul>
<li>（如果会用node）知道route，middleware，cluster，nodemon,pm2,server-side rendering么解释一下backbone的mvc实现方式。</li>
</ul>
<h3 id="7、javascript对象的几种创建方式"><a href="#7、javascript对象的几种创建方式" class="headerlink" title="7、javascript对象的几种创建方式"></a>7、javascript对象的几种创建方式</h3><ul>
<li>javascript创建对象简单的说,<br>无非就是使用内置对象或各种自定义对象，当然还可以用JSON；<br>但写法有很多种，也能混合使用。</li>
<li><p>1、对象字面量的方式  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>2、用function来模拟无参的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person();<span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class</span></div><div class="line">person.name=<span class="string">"Mark"</span>;</div><div class="line">person.age=<span class="string">"25"</span>;</div><div class="line">person.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(person.name+<span class="string">" hello..."</span>);</div><div class="line"> &#125;</div><div class="line">person.work();</div></pre></td></tr></table></figure>
</li>
<li><p>3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Pet(name,age,hobby)&#123;</div><div class="line">   this.name=name;//this作用域：当前对象</div><div class="line">   this.age=age;</div><div class="line">   this.hobby=hobby;</div><div class="line">   this.eat=function()&#123;</div><div class="line">      alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象</div><div class="line">maidou.eat();//调用eat方法</div></pre></td></tr></table></figure>
</li>
<li><p>4、用工厂方式来创建（内置对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var wcDog =new Object();</div><div class="line">wcDog.name=&quot;旺财&quot;;</div><div class="line">wcDog.age=3;</div><div class="line">wcDog.work=function()&#123;</div><div class="line">  alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);</div><div class="line">&#125;</div><div class="line">wcDog.work();</div></pre></td></tr></table></figure>
</li>
<li><p>5、用原型方式来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Dog()&#123;</div><div class="line"> &#125;</div><div class="line"> Dog.prototype.name=&quot;旺财&quot;;</div><div class="line"> Dog.prototype.eat=function()&#123;</div><div class="line"> alert(this.name+&quot;是个吃货&quot;);</div><div class="line"> &#125;</div><div class="line"> var wangcai =new Dog();</div><div class="line"> wangcai.eat();</div></pre></td></tr></table></figure>
</li>
<li><p>6、用混合方式来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   function Car(name,price)&#123;</div><div class="line">     this.name=name;</div><div class="line">     this.price=price;</div><div class="line">    &#125;</div><div class="line">    Car.prototype.sell=function()&#123;</div><div class="line">      alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);</div><div class="line">     &#125;</div><div class="line">   var camry =new Car(&quot;凯美瑞&quot;,27);</div><div class="line">camry.sell();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8、documen-write和innerHTML的区别"><a href="#8、documen-write和innerHTML的区别" class="headerlink" title="8、documen.write和innerHTML的区别"></a>8、documen.write和innerHTML的区别</h3><h3 id="9、简述一下handlebars的基本用法"><a href="#9、简述一下handlebars的基本用法" class="headerlink" title="9、简述一下handlebars的基本用法"></a>9、简述一下handlebars的基本用法</h3><h3 id="10、jquery的源码看过吗？能不能简单的说下他的视线原理？"><a href="#10、jquery的源码看过吗？能不能简单的说下他的视线原理？" class="headerlink" title="10、jquery的源码看过吗？能不能简单的说下他的视线原理？"></a>10、jquery的源码看过吗？能不能简单的说下他的视线原理？</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、如何解决跨域问题&quot;&gt;&lt;a href=&quot;#1、如何解决跨域问题&quot; class=&quot;headerlink&quot; title=&quot;1、如何解决跨域问题&quot;&gt;&lt;/a&gt;1、如何解决跨域问题&lt;/h3&gt;&lt;p&gt;  nginx代理，或后端设置，&lt;/p&gt;
&lt;h3 id=&quot;2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）&quot;&gt;&lt;a href=&quot;#2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）&quot; class=&quot;headerlink&quot; title=&quot;2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）&quot;&gt;&lt;/a&gt;2、移动端的点击事件有延迟，时间是多久，为什么会有，怎么解决这个延时（click有300ms延迟，为了实现Safari的双击时间的设计，浏览器要知道你是不是双击操作。）&lt;/h3&gt;
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="JS" scheme="http://blog.ypintao.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>从输入url到浏览器显示页面发生了什么</title>
    <link href="http://blog.ypintao.com/2016/07/01/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/JS/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://blog.ypintao.com/2016/07/01/技术/web前端/JS/从输入url到浏览器显示页面发生了什么/</id>
    <published>2016-06-30T16:00:00.000Z</published>
    <updated>2017-03-22T07:09:00.784Z</updated>
    
    <content type="html"><![CDATA[<p>#####这个过程大致分为两个部分：网络通信和页面渲染。</p>
<h6 id="1、网络通信"><a href="#1、网络通信" class="headerlink" title="1、网络通信"></a>1、网络通信</h6><p>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层，传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走：</p>
<p>如图</p>
<p>应用层——&gt;传输层——&gt;网络层——&gt;数据链路层</p>
<p>HTTP客户端——&gt;TCP—-&gt;IP——&gt;网络</p>
<ul>
<li><p>在浏览器输入url<a id="more"></a></p>
</li>
<li><p>应用层DNS解析域名</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">客户端先检查本地是否有对应的ip地址，</div><div class="line">若找到则返回响应的ip地址。</div><div class="line">若没有找到则请求上级DNS服务器，</div><div class="line">直至找到或到根节点。</div></pre></td></tr></table></figure>
<ul>
<li>应用层客户端发送HTTP请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP请求包括请求报头和请求主体两个部分</div><div class="line">，其中请求报头包含至关重要的信息，</div><div class="line">包括请求的方法GET、POST,、目标url、遵循的协议（http，https，ftp），</div><div class="line">返回的信息是否需要缓存，以及客户端是否发送cookie等。</div></pre></td></tr></table></figure>
<ul>
<li>传输层TCP传输报文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">位于传输层的TCP协议为传输报文提供可靠的字节流服务，他为了方便传</div><div class="line">输，将打款的数据分割成以报文段为单位的数据包进行管理，并为他们编</div><div class="line">号，方便服务器接收时能准确地还原报文信息，TCP协议通过三次握手等</div><div class="line">方法保证传输的安全可靠。</div><div class="line">  三次握手的过程是，发送端先发送一个带有SYN标志的数据包给接收</div><div class="line">端，以一定的延时时间内，等待接收的回复，接收端收到数据包后，传回</div><div class="line">一个带有SYN/ACK标志的数据包以表示传达确认信息，接收方收到后再发</div><div class="line">送一个带有ACK标志的数据包给接收端表示握手成功，在这个过程中，如</div><div class="line">果发送端在规定的延时时间内没有收到回复则默认接收方没有收到请求，</div><div class="line">而在次发送，知道收到回复为止</div></pre></td></tr></table></figure>
<ul>
<li>网络层IP协议查询MAC地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  IP协议的作用是把TCP分割好的各种数据包，传送给接收方。而要保证确</div><div class="line">实能够传到接收方还需要接收方的MAC地址，也就是物理地址，IP地址和</div><div class="line">MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC</div><div class="line">地址一般是固定不变的，Arp协议，可以将IP地址解析成对应的MAC地</div><div class="line">址，当通信的双方不再同一个局域网时，需要多次中转才能到达最终的目</div><div class="line">标，在中转的过程中，需要通过下一个中转站的MAC地址来搜索下一个中</div><div class="line">转目标。8135</div></pre></td></tr></table></figure>
<ul>
<li>数据到达数据链路层</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在找到对方的mac地址以后，就将数据发送到数据链路层传输，这时，客</div><div class="line">户端发送请求的阶段结束</div></pre></td></tr></table></figure>
<ul>
<li>服务器接收数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">接收端的服务器在链路层收到数据包，再层层向上直到应用层，这过程中</div><div class="line">包括在运输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报</div><div class="line">文，</div></pre></td></tr></table></figure>
<ul>
<li>服务器响应请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回</div><div class="line">响应的报文，响应的报文中包括一个重要的信息------状态码。状态码由三</div><div class="line">位数字组成，其中比较常见的是200OK表示成功，301表示永久重定向。</div><div class="line">即请求的资源已经永久转移到新的位置。在返回301状态码的同事，响应</div><div class="line">报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变</div><div class="line">再重新发送。</div></pre></td></tr></table></figure>
<ul>
<li>服务器返回相应文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请求成功后，服务器会返回相应的HTML文件，接下来就到了页面的渲染</div><div class="line">阶段。</div></pre></td></tr></table></figure>
<h6 id="2、页面渲染"><a href="#2、页面渲染" class="headerlink" title="2、页面渲染"></a>2、页面渲染</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">浏览器渲染页面的过程是这样的：</div><div class="line">解析HTML以构建DOM树----&gt;构建渲染树----&gt;布局渲染树----&gt;绘制渲染</div><div class="line">树。</div><div class="line">DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树种加入css</div><div class="line">或者html种的style样式而形成的。渲染树只包含需要显示在页面中的DOM</div><div class="line">元素，像&lt;head&gt;元素或display属性值为none的元素都不在渲染树中。</div><div class="line">在浏览器还没有接收到完整的html文件时，他就开始渲染页面了。在遇到</div><div class="line">外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上</div><div class="line">述步骤，在收到css文件后会对已经渲染的页面重新渲染，加入他们应有的</div><div class="line">样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页</div><div class="line">面的重绘或重排。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#####这个过程大致分为两个部分：网络通信和页面渲染。&lt;/p&gt;
&lt;h6 id=&quot;1、网络通信&quot;&gt;&lt;a href=&quot;#1、网络通信&quot; class=&quot;headerlink&quot; title=&quot;1、网络通信&quot;&gt;&lt;/a&gt;1、网络通信&lt;/h6&gt;&lt;p&gt;互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层，传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走：&lt;/p&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;应用层——&amp;gt;传输层——&amp;gt;网络层——&amp;gt;数据链路层&lt;/p&gt;
&lt;p&gt;HTTP客户端——&amp;gt;TCP—-&amp;gt;IP——&amp;gt;网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在浏览器输入url
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="JS" scheme="http://blog.ypintao.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>关于单位px,rem,em</title>
    <link href="http://blog.ypintao.com/2016/06/11/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/JS/%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BD%8Dpx,rem,em/"/>
    <id>http://blog.ypintao.com/2016/06/11/技术/web前端/JS/关于单位px,rem,em/</id>
    <published>2016-06-10T16:00:00.000Z</published>
    <updated>2017-03-22T07:09:09.396Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>px(像素)，相对长度单位，像素px是相对于显示器屏幕分辨率而言的，</p>
</li>
<li><p>em 相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸<br>未被人为设置，则相对于浏览器的默认字体尺寸。<a id="more"></a></p>
</li>
<li><p>rem也是相对长度单位，但相对的知识html根元素。</p>
</li>
<li><p>vw代表视窗（viewport）的宽度为1%,如果视窗的宽度为1000px，那么50vw =500px</p>
</li>
<li><p>vh代表窗口高度的百分，如果视窗的高度为800px,那么50vh = 400px</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;px(像素)，相对长度单位，像素px是相对于显示器屏幕分辨率而言的，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;em 相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸&lt;br&gt;未被人为设置，则相对于浏览器的默认字体尺寸。
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/JS/"/>
    
    
      <category term="JS" scheme="http://blog.ypintao.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HTML5问题汇总</title>
    <link href="http://blog.ypintao.com/2016/05/01/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/HTML5/HTML5%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ypintao.com/2016/05/01/技术/web前端/HTML5/HTML5问题汇总/</id>
    <published>2016-04-30T16:00:00.000Z</published>
    <updated>2017-03-22T06:57:12.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述一下你对html语义化的理解"><a href="#简述一下你对html语义化的理解" class="headerlink" title="简述一下你对html语义化的理解"></a>简述一下你对html语义化的理解</h3><p>网页验证码是干嘛的，是为了解决什么安全问题<br>html5有哪些新特性，移除了哪些元素，如何处理html5新标签的浏览器兼容问题，如何区分html和html5，</p>
<h3 id="浏览器是怎么对html5的离线存储资源进行管理和加载的呢"><a href="#浏览器是怎么对html5的离线存储资源进行管理和加载的呢" class="headerlink" title="浏览器是怎么对html5的离线存储资源进行管理和加载的呢"></a>浏览器是怎么对html5的离线存储资源进行管理和加载的呢</h3><h3 id="介绍下你对浏览器内核的理解"><a href="#介绍下你对浏览器内核的理解" class="headerlink" title="介绍下你对浏览器内核的理解"></a>介绍下你对浏览器内核的理解<a id="more"></a></h3><p>主要分成两部分：</p>
<ul>
<li>渲染引擎（layout engineer或rendering）和JS引擎<br>渲染引擎：负责取得网页的内容（html好，xml，图像等等）、整理讯息（例如加入css等），以及计算网页的显示方式，然后会输出至显示器，浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同，所有网页浏览器，电子邮件客户端以及其他需要编辑显示网络内容的应用程序。</li>
<li>js引擎则：解析和执行javascript来实现网页的动态效果，最开始渲染引擎和js引擎并没有区分的很明确，后来js引擎越来越独立，内核就倾向于指渲染引擎。</li>
</ul>
<h3 id="html5为什么只需要些-lt-DOCTYPE-HTML-gt"><a href="#html5为什么只需要些-lt-DOCTYPE-HTML-gt" class="headerlink" title="html5为什么只需要些&lt;!DOCTYPE HTML&gt;"></a>html5为什么只需要些&lt;!DOCTYPE HTML&gt;</h3><ul>
<li>HTML5不是基于SGML 因此不需要对DTD进行引用，但是余姚doctype来规范浏览器的行为（让牛栏器按照他们应该的方式运行，）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的的文档类型；</li>
</ul>
<h3 id="webSocket如何兼容低浏览器？（阿里）"><a href="#webSocket如何兼容低浏览器？（阿里）" class="headerlink" title="webSocket如何兼容低浏览器？（阿里）"></a>webSocket如何兼容低浏览器？（阿里）</h3><h3 id="label的作用是什么？是怎么用的（加for或包裹）"><a href="#label的作用是什么？是怎么用的（加for或包裹）" class="headerlink" title="label的作用是什么？是怎么用的（加for或包裹）"></a>label的作用是什么？是怎么用的（加for或包裹）</h3><h3 id="iframe有哪些缺点？"><a href="#iframe有哪些缺点？" class="headerlink" title="iframe有哪些缺点？"></a>iframe有哪些缺点？</h3><h3 id="实现不适用border画出1px高的线，在不同的浏览器的怪异模式下都能保持统一效果"><a href="#实现不适用border画出1px高的线，在不同的浏览器的怪异模式下都能保持统一效果" class="headerlink" title="实现不适用border画出1px高的线，在不同的浏览器的怪异模式下都能保持统一效果"></a>实现不适用border画出1px高的线，在不同的浏览器的怪异模式下都能保持统一效果</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简述一下你对html语义化的理解&quot;&gt;&lt;a href=&quot;#简述一下你对html语义化的理解&quot; class=&quot;headerlink&quot; title=&quot;简述一下你对html语义化的理解&quot;&gt;&lt;/a&gt;简述一下你对html语义化的理解&lt;/h3&gt;&lt;p&gt;网页验证码是干嘛的，是为了解决什么安全问题&lt;br&gt;html5有哪些新特性，移除了哪些元素，如何处理html5新标签的浏览器兼容问题，如何区分html和html5，&lt;/p&gt;
&lt;h3 id=&quot;浏览器是怎么对html5的离线存储资源进行管理和加载的呢&quot;&gt;&lt;a href=&quot;#浏览器是怎么对html5的离线存储资源进行管理和加载的呢&quot; class=&quot;headerlink&quot; title=&quot;浏览器是怎么对html5的离线存储资源进行管理和加载的呢&quot;&gt;&lt;/a&gt;浏览器是怎么对html5的离线存储资源进行管理和加载的呢&lt;/h3&gt;&lt;h3 id=&quot;介绍下你对浏览器内核的理解&quot;&gt;&lt;a href=&quot;#介绍下你对浏览器内核的理解&quot; class=&quot;headerlink&quot; title=&quot;介绍下你对浏览器内核的理解&quot;&gt;&lt;/a&gt;介绍下你对浏览器内核的理解
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML5" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://blog.ypintao.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>CSS问题汇总</title>
    <link href="http://blog.ypintao.com/2016/05/01/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/CSS/CSS%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ypintao.com/2016/05/01/技术/web前端/CSS/CSS的问题汇总/</id>
    <published>2016-04-30T16:00:00.000Z</published>
    <updated>2017-03-22T06:57:15.640Z</updated>
    
    <content type="html"><![CDATA[<p>###浏览器是怎样解析css选择器的？</p>
<ul>
<li>按照从上到下,从右到左的顺序解析</li>
</ul>
<p>###css优先级算法如何计算（ICE法则）<a id="more"></a></p>
<ul>
<li>css优化、提高性能的方法有哪些？</li>
</ul>
<p>###设置元素浮动后，该元素的display值是多少？（自动变成display：block）</p>
<p>###为什么要初始化css样式。</p>
<ul>
<li>统一去掉浏览器的默认样式</li>
</ul>
<p>###对BFC规范（块级格式化上下文）的理解</p>
<p>###让页面里的字体变清晰，变细用css怎么做？（-webkit-font-smoothing:antialiased;）</p>
<p>###使用css预处理器吗？喜欢哪个？</p>
<p>###经常遇到的浏览器的兼容性问题有哪些？原因，解决方法是什么，常用hack的技巧，</p>
<p>###display有哪些值？说明他们的作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  display:none 隐藏</div><div class="line">  </div><div class="line">display:block 块级元素</div><div class="line"></div><div class="line">display:inline  默认</div><div class="line"></div><div class="line">display:inline-block</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###浏览器是怎样解析css选择器的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照从上到下,从右到左的顺序解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###css优先级算法如何计算（ICE法则）
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="CSS" scheme="http://blog.ypintao.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>图表测试</title>
    <link href="http://blog.ypintao.com/2016/03/03/hexo%E6%B5%8B%E8%AF%95/%E5%9B%BE%E8%A1%A8%E6%B5%8B%E8%AF%95/"/>
    <id>http://blog.ypintao.com/2016/03/03/hexo测试/图表测试/</id>
    <published>2016-03-02T16:00:00.000Z</published>
    <updated>2017-03-24T10:24:10.052Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>SVN((SVN server))——表示这个节点形状是一个圆。</li>
<li>|read only|SVN——以这种方式添加节点之间的文本。</li>
<li>graph TD，从上至下</li>
<li>BT</li>
<li>RL</li>
<li>LR<a id="more"></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">graph LR</div><div class="line">    client1--&gt;|read / write|SVN(SVN server)</div><div class="line">    client2--&gt;|read only|SVN</div><div class="line">    client3--&gt;|read / write|SVN</div><div class="line">    client4--&gt;|read only|SVN</div><div class="line">    client5(...)--&gt;SVN</div><div class="line">    SVN---|store the data|sharedrive</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">graph TD</div><div class="line">    client1--&gt;|read / write|SVN(SVN server)</div><div class="line">    client2--&gt;|read only|SVN</div><div class="line">    client3--&gt;|read / write|SVN</div><div class="line">    client4--&gt;|read only|SVN</div><div class="line">    client5(...)--&gt;SVN</div><div class="line">    SVN---|store the data|sharedrive</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">graph TD</div><div class="line">    subgraph SVN Architecture</div><div class="line">    client1--&gt;|read / write|SVN((SVN server))</div><div class="line">    client2--&gt;|read only|SVN</div><div class="line">    client3--&gt;|read / write|SVN</div><div class="line">    client4--&gt;|read only|SVN</div><div class="line">    client5(...)--&gt;SVN</div><div class="line">    SVN---|store the data|sharedrive</div><div class="line">    end</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;SVN((SVN server))——表示这个节点形状是一个圆。&lt;/li&gt;
&lt;li&gt;|read only|SVN——以这种方式添加节点之间的文本。&lt;/li&gt;
&lt;li&gt;graph TD，从上至下&lt;/li&gt;
&lt;li&gt;BT&lt;/li&gt;
&lt;li&gt;RL&lt;/li&gt;
&lt;li&gt;LR
    
    </summary>
    
      <category term="test" scheme="http://blog.ypintao.com/categories/test/"/>
    
    
      <category term="test" scheme="http://blog.ypintao.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>vim使用</title>
    <link href="http://blog.ypintao.com/2016/02/27/%E6%8A%80%E6%9C%AF/Linux/node%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vim%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.ypintao.com/2016/02/27/技术/Linux/node开发工具/vim使用/</id>
    <published>2016-02-26T16:00:00.000Z</published>
    <updated>2017-03-22T04:59:11.876Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>模式了解<br>  vi有三种模式，即：一般模式、编辑模式、命令模式</p>
<h2 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h2><p>  也是默认模式，用vi打开一个文件就直接进入了一般模式。在此模式下，你可以进行删除字符、删除整行、字符替换、复制粘贴等操作<a id="more"></a></p>
<h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>  用户vi打开文件进入一般模式，当只要按下【i I a A o O r R】中任何一个字母时，便会进入到编辑模式。<br>  <img src="http://p1.pstatp.com/large/1994000b2cd65083a2b5" alt="t"><br>  当进入编辑模式下，文档左下角会出现”INSERT”或”REPLACE”字样；若要退出编辑模式，按下键盘Esc键即可返回到一般模式</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>  在一般模式下，可以用键盘输入【：/?】任意一个字符便会进到命令模式，同时光标移动到最底一行，等待用户下一步的输入。在此模式下，用户可以执行常见的如 读取、保存、批量替换、显示行号、退出编辑器等操作，如”:set nu”便可在文档中显示行号<br>  <img src="http://p9.pstatp.com/large/18fb000557f28195c16a" alt="dd"></p>
</li>
<li><p>常用按键指令</p>
<h2 id="光标的移动"><a href="#光标的移动" class="headerlink" title="光标的移动"></a>光标的移动</h2><p>  <img src="http://p1.pstatp.com/large/18fb000557f4f6592e9a" alt="光标移动"><br>  <img src="http://p1.pstatp.com/large/18fb000557f5a3976c80" alt="光标移动"></p>
<h2 id="复制与粘贴"><a href="#复制与粘贴" class="headerlink" title="复制与粘贴"></a>复制与粘贴</h2><p>  <img src="http://p3.pstatp.com/large/18fb000557f75a63af7c" alt="复制与粘贴"><br>  <img src="http://p1.pstatp.com/large/18fb000557f8b1e6e9c0" alt="复制与粘贴"></p>
<h2 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h2><p>  <img src="http://p3.pstatp.com/large/199b000a396e152eccbd" alt="搜索与替换"><br>  <img src="http://p1.pstatp.com/large/18fb000557fa4f0ea51e" alt="搜索与替换"></p>
<h2 id="命令模式下的指令"><a href="#命令模式下的指令" class="headerlink" title="命令模式下的指令"></a>命令模式下的指令</h2><p>  <img src="http://p3.pstatp.com/large/199b000a396fa6869771" alt="命令模式下的指令"></p>
<h2 id="编辑模式下的指令"><a href="#编辑模式下的指令" class="headerlink" title="编辑模式下的指令"></a>编辑模式下的指令</h2><p>  <img src="http://p1.pstatp.com/large/18fb000557fb8bf8f79e" alt="编辑模式下的指令"></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;模式了解&lt;br&gt;  vi有三种模式，即：一般模式、编辑模式、命令模式&lt;/p&gt;
&lt;h2 id=&quot;一般模式&quot;&gt;&lt;a href=&quot;#一般模式&quot; class=&quot;headerlink&quot; title=&quot;一般模式&quot;&gt;&lt;/a&gt;一般模式&lt;/h2&gt;&lt;p&gt;  也是默认模式，用vi打开一个文件就直接进入了一般模式。在此模式下，你可以进行删除字符、删除整行、字符替换、复制粘贴等操作
    
    </summary>
    
      <category term="Linux" scheme="http://blog.ypintao.com/categories/Linux/"/>
    
      <category term="node开发工具" scheme="http://blog.ypintao.com/categories/Linux/node%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="node开发工具" scheme="http://blog.ypintao.com/tags/node%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试谈薪资的6大技巧</title>
    <link href="http://blog.ypintao.com/2016/02/21/%E7%94%9F%E6%B4%BB/%E9%9D%A2%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E8%B0%88%E8%96%AA%E8%B5%84%E7%9A%846%E5%A4%A7%E6%8A%80%E5%B7%A7/"/>
    <id>http://blog.ypintao.com/2016/02/21/生活/面试/程序员面试谈薪资的6大技巧/</id>
    <published>2016-02-20T16:00:00.000Z</published>
    <updated>2017-03-21T09:56:53.758Z</updated>
    
    <content type="html"><![CDATA[<p>面试官： 在我们这儿工作，您希望有什么样的薪资待遇？  </p>
<p>提示：了解该公司所在地区、所属行业、公司规模等信息，你的薪水要求应该在该公司所在地 区、行业、公司规模相应的薪水范围之内。尽可能提供一个你期望的薪水范围，而不是具体的 薪金数。 求职者：其实工资并不是我决定工作机会的唯一因素，如果您一定要我回答这个问题，只能说我希望以我所受的教育背景及工作经验，我希望我的工资不低于年薪50,000元。<a id="more"></a></p>
<p>面试官： 你认为每年加薪的幅度是多少？</p>
<p>提示：通常, 比较可靠的回答是: 你希望收入的增长和生活水平的提高保持一致。你还应该提 到，你的业绩将是加薪的主要因素。 求职者：总体来说，取决于我个人的业绩和公司的业绩（盈利状况）。但一般而言，至少和生 活水平的提高保持一致。</p>
<p>面试官： 你上一份工作的收入是多少？  </p>
<p>提示：有时候面试人员希望得到一个比较明确的答案。记住，在陈述你的收入时，要把你的整个福利收入也加在上面。在有的公司福利收入可以使你的年收入增加30%或更多。求职者：我过去的三年内一直在ABC公司工作，我是大学一毕业就在这个公司的，当时并没有管理经验。这三年中，我积累了很多管理和财务方面的技巧。现在ABC公司给我的薪水是非常富有竞争性的。</p>
<p>面试官： 你愿意降低你的标准吗？  </p>
<p>提示：如果这确实是你非常希望得到的工作，那么，你应该考虑在开始时工资有所降低。应强 调你可以把工作做得很好，并设法了解公司调整你薪水的时间。另外，对你能够接受的最低数 额应心里有数，但千万不要把这个数字告诉给面试人员。求职者：由于我对该职位非常感兴趣，我可以考虑接受低一些的薪水，你也需要时间让我证明 我的能力。我相信我可以干得十分出色，如果我能证明我的能力，你是否会考虑对我的薪水作 一些调整呢，比如说，在三个月后。</p>
<p>面试官： 你认为我们提供给你的薪水如何？  </p>
<p>提示：在回答这个问题之前，首先确定这是否是正式聘用的工资数额，也许面试人只是想了解你的工资要求。如果是正式聘用的工资数额，你要确定自己是否能够接受这个数额。在西方国 家，多数雇主希望你能跟他们进一步商量；而在亚洲国家，则相反。如果这个数目大大低于你的期望，可以有技巧性地询问其它的福利项目是怎样的。求职者：这个数字跟我期望的非常接近，不过我的期望值要稍高些。您是否可以提供一个大致的薪资范围？</p>
<p>面试官： 能否告诉我，你的工资调整纪录？  </p>
<p>提示：在这个问题中，面试人员只是想知道是否你一直原职不变，或者说是否你不断得到晋升的机会。所以，尽量避免提供薪资具体数额，除非他们要求。求职者：三年来，我一直在ABC公司工作，曾得到两次职务提升。ABC公司每年薪资调整的幅度不是太大，但由于我的工作总是十分优秀，每年的薪资调整都接近调整的最高水平。我目前的 工资已比我开始工作的第一年提高近40%。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试官： 在我们这儿工作，您希望有什么样的薪资待遇？  &lt;/p&gt;
&lt;p&gt;提示：了解该公司所在地区、所属行业、公司规模等信息，你的薪水要求应该在该公司所在地 区、行业、公司规模相应的薪水范围之内。尽可能提供一个你期望的薪水范围，而不是具体的 薪金数。 求职者：其实工资并不是我决定工作机会的唯一因素，如果您一定要我回答这个问题，只能说我希望以我所受的教育背景及工作经验，我希望我的工资不低于年薪50,000元。
    
    </summary>
    
      <category term="生活" scheme="http://blog.ypintao.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="面试" scheme="http://blog.ypintao.com/categories/%E7%94%9F%E6%B4%BB/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://blog.ypintao.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于libuv</title>
    <link href="http://blog.ypintao.com/2015/07/21/%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF/Node%20Express/%E5%85%B3%E4%BA%8Elibuv/"/>
    <id>http://blog.ypintao.com/2015/07/21/技术/后端/Node Express/关于libuv/</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2017-03-21T09:46:33.078Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍下libuv，libuv 是一个高性能事件驱动的程序库，封装了 Windows 和 Unix 平台一些底层特性，为开发者提供了统一的 API。libuv 采用了 异步 (asynchronous), 事件驱动 (event-driven)的编程风格, <a id="more"></a>其主要任务是为开人员提供了一套事件循环和基于I/O(或其他活动)通知的回调函数, libuv 提供了一套核心的工具集, 例如定时器, 非阻塞网络编程的支持, 异步访问文件系统, 子进程以及其他功能。 可见nodejs的一切异步操作都是基于libuv来实现的，有了它的这些api我们也就可以编写出异步的nodejs模块了。<br>最好结合github上的test和liuv.h来看，更加容易弄懂 中文版的libuv手册：<a href="http://forhappy.github.io/uvbook/index.html" target="_blank" rel="external">http://forhappy.github.io/uvbook/index.html</a> libuv项目地址：<a href="https://github.com/joyent/libuv" target="_blank" rel="external">https://github.com/joyent/libuv</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先介绍下libuv，libuv 是一个高性能事件驱动的程序库，封装了 Windows 和 Unix 平台一些底层特性，为开发者提供了统一的 API。libuv 采用了 异步 (asynchronous), 事件驱动 (event-driven)的编程风格,
    
    </summary>
    
      <category term="后端" scheme="http://blog.ypintao.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Node" scheme="http://blog.ypintao.com/categories/%E5%90%8E%E7%AB%AF/Node/"/>
    
    
      <category term="Node" scheme="http://blog.ypintao.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>备份，删除mongodb数据库释放空间</title>
    <link href="http://blog.ypintao.com/2015/04/30/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E5%A4%87%E4%BB%BD%EF%BC%8C%E5%88%A0%E9%99%A4mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4/"/>
    <id>http://blog.ypintao.com/2015/04/30/技术/数据库/mongodb/备份，删除mongodb数据库释放空间/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2017-03-21T09:46:07.697Z</updated>
    
    <content type="html"><![CDATA[<p>所以介绍用db.copyDatabase可以备份复制数据的方法。<br>1.db.copyDatabase(“from”,”to”,”127.0.0.1:16161”);复制出一个新的to数据库。这个已经是最小数据占用的数据。会在数据目录下产生to的相关数据文件。<br>2.将所有程序的配置从from库改为to库。测试无误。<br>3.这时可以删除from库。方法。use from 后 db.dropDatabase()<a id="more"></a>。这个方法的好处是可以时间将磁盘上的数据删除掉。节省出很大的空间。</p>
<p>禁止数据库预分配空间<br>在启动数据库时可以选择noprealloc参数，禁止数据库预分配空间，但会影响到插入效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所以介绍用db.copyDatabase可以备份复制数据的方法。&lt;br&gt;1.db.copyDatabase(“from”,”to”,”127.0.0.1:16161”);复制出一个新的to数据库。这个已经是最小数据占用的数据。会在数据目录下产生to的相关数据文件。&lt;br&gt;2.将所有程序的配置从from库改为to库。测试无误。&lt;br&gt;3.这时可以删除from库。方法。use from 后 db.dropDatabase()
    
    </summary>
    
      <category term="数据库" scheme="http://blog.ypintao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="http://blog.ypintao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://blog.ypintao.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何提高影响力</title>
    <link href="http://blog.ypintao.com/2015/04/28/%E7%94%9F%E6%B4%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%BD%B1%E5%93%8D%E5%8A%9B/"/>
    <id>http://blog.ypintao.com/2015/04/28/生活/程序员如何提高影响力/</id>
    <published>2015-04-27T16:00:00.000Z</published>
    <updated>2017-03-21T10:32:01.043Z</updated>
    
    <content type="html"><![CDATA[<p>影响力，让梦想离你更近。<br>试想一下，有一天你开发了一个新的语言。它比现有的某某主流软件，运行效率将提高了50%，开发效率提高了100%。接着，你在github上 release了0.1，但是由于出现某个开发难题，你需要别人的帮助。而这时，你找不到有效的途径去找到那些真正会用它的人。接着出现了一个新的语言可 以达到一样的效果，而这个项目就死于腹中，我记得mruby刚刚只写了一个README.md的时候，就获得了上千个star。<br>如何提高影响力，为自己代言<a id="more"></a></p>
<p>每个人都可以是一个品牌，对于一个程序员来说，我们的ID就是我们的品牌。而构成品牌的有多个要素:<br>博客<br>Github<br>Weibo(or Twitter)<br>StackOverflow(or SegmentFault, Zhihu)<br>等等。<br>搭建一个跨平台的平台</p>
<p>连接各个平台的核心是我们的ID。<br>第一个平台指的是不同的网站，如我们的博客、Github、知乎等等，第二个平台指的是我们的影响力。<br>So，在开始的时候我们需要有一个统一的ID，来标识我们的身份:我是谁，你在xx网站上看到的那个xx就是我。刚开始的时候，我在CSDN、 Github上的ID(gmszone)和我的博客的域名(Phodal)是不一样的，因为当时的域名(gmszone.com)握在别人的手上，于是我 便想办法将两个ID改了过来（ps: github提供迁移)。<br>于是，这时就可以开始使用跨平台的平台了。<br>构建平台</p>
<p>小博客也会有成长的一天。<br>对于像我这样一个个默默无闻地人来说，用户可能会有下面几种不同的方法来知道我:<br>live example<br>用户 -&gt; 搜索{谷歌,百度,必应} -&gt; 博客 -&gt; {Weibo,Github}<br>用户 -&gt; 微博 -&gt; {Github, 博客}<br>用户 —&gt; Github -&gt; 博客<br>用户 -&gt; {知乎, SegmentFault} -&gt; {Weibo,Github,博客}<br>博客</p>
<p>刚开始在CSDN上写博客的时候，一开始的访问量很少，慢慢地就多了。有一天发现这样的博客不是自己想要的，于是建了自己的博客，一开始的流量是 0。像CSDN这样的网站推荐一些文章到首页，如果能这样便是幸运的。在经历大半年的几乎零流量之后，开始慢慢增长了。到了今天，一共有470篇博客(有 一些是出于测试SEO目的写成多篇文章)。一天的PageView大平均有五百左右，主要来源是搜索引擎，百度200左右，谷歌50左右，必应10左右。<br>用户故事</p>
<p>对于一个程序员来说，必须在某种程度上熟悉怎么搜索自己想要的内容，即关键字。如我们想要知道如何在OpenWRT OS上用Python，那么我们会搜索OpenWRT Python。于是，这个时候我们博客的标题带有OpenWRT Python，那么我们可能就中奖了。<br>故事，告诉我们好的标题很重要。重复这个主题也很重要，会有一个更好的排名。至于，如何更好地排到第一，就是SEO(搜索引擎优化)的话题了。<br>笔记</p>
<p>一开始要写一个博客是比较难的，没有流量、没有评论。所以，一个好的切入点是: 笔记。最好是那种网上很少的内容的笔记，虽说很多人不愿意去做这个，但是这是一个很好的方向。<br>一个技术博客里面的内容应该是两种类型:<br>技术<br>理论<br>技术型可以带来流量，理论型的可以带来评论。理想的话，两者会相辅相成的，但是在我们刚处于学习期的时候。那么那些Note，可以给我们带来一些流量，也带来一些信心。如果，只是想着一开始我就只写一些长篇大论的话，那么只是就是拿了80%的时间做了20%的事。<br>以用户搜索的过程来说，用户是有目的的进行搜索。换句话说，在我们日常工作的时候，我们只关心和我们工作相关的内容。而在受众来，正常情况下，技术型的博文、笔记可以带来流量的主要原因是: 大部分人都是初学者。<br>70 percent<br>理论性的内容，更适合更高级别的开发者，这样的受众较少。<br>上头条</p>
<p>而在今天有其他的平台，可以借用来推销自己的:<br>开发者头条<br>极客头条<br>掘金稀土<br>…<br>网上的IT新闻、博客都是互相Copy，对于一些软文(如本文)来说。这也是期触及率高的原因，通常来说这样可以带来大量的流量。记得在原文中留个原文链接，附张图片(自己博客的图片)来保证:Google把原文指向你的博客，而不是免费为别人打工。<br>提升</p>
<p>除了是一个很好的展示平台，也是一个很好的测试平台。作为一个Web Developer，测试过<br>Nginx Log分析(~600M)<br>New Relic<br>SEO<br>AutoComplete<br>重构网站<br>…<br>Github</p>
<p>将自己尝试的不同技术栈的内容丢到Github上，加上适当地文档、博客，就变成了一个很好的Demo。然而，不止于此，越来越多地人开始在Github寻找人才，因为他们乐于付出，也乐于分离。曾经因为Github上的项目:<br>申请WebStorm开源License<br>Review英文版书籍<br>…(有些不方便透露)<br>而在Github上的项目其实不仅仅只有一些库:<br>库和框架: 和jQuery<br>系统: 如Linux、hhvm、docker<br>配置集: 如dotfiles<br>辅助工具: 如oh-my-zsh<br>工具: 如Homewbrew和Bower<br>资料收集: 如free programming books，You-Dont-Know-JS，Font-Awesome<br>其他:简历如Resume，博客<br>所以，可以尝试不同的切入点使用Github。<br>在某种程度上来说，一个人在Gihub上的粉丝数量会帮助他的项目在初期获取更多的人气。这样就有助于其下一步开展项目，当然也会在某种程度上更好看Blabla。<br>提升</p>
<p>之前写过一篇《如何通过github提升自己》中说到了一些细节，大致上还是那些东西，Github与Trello、Travis-CI、Coveralls、SauceLabs、Code Climate，配合得很好。已经可以接近于我们在一些项目上用到的功能，因此拿他们搭建一个好的开发环境完全不是问题。<br>Travis CI:支持Node.js、Python、Ruby、PHP等二十几种语言，也支持MySQL、PostgreSQL、MongoDB、Redis等数据库。<br>Coveralls:可以用来查看代码的测试覆盖率。<br>SauceLabs:可以用来跑Selenium功能测试等等<br>Code Climate:查看代码的坏味道。<br>在我们试着去保证测试覆盖率、代码质量等等的时候，我们就可以学到一些知识，如使用不同语言测试框架的Mock、Stub、FakeServer等等。<br>扩大影响力</p>
<p>上面的两部分属于打造平台部分，而如Weibo、知乎等则属于扩大影响力。<br>在某种时候，博客、Github都更像是个人的平台。如Weibo、知乎、SegmentFault、CSDN等等的开发者社区，也可以为自己的博 客、Github带来流量，而这一些都是互相促进的。如果我们在其中的一个网站上表现得很好的话，那么在另外一个网站上我们也很容易聚集同样的粉丝。如， 我最常用的一个作法是: 将自己写得相对比较好的一些博客复制到CSDN、SegemntFault、图灵社区等等，并适当地推到CSDN首页、开发者头条等等。<br>由于写作的开发人员是有限的，所以通常在某某头条上的推荐，会成为某博客园上的新闻，接着会有成群接队的小站开始Copy。同时，这些文章又会推到 他们的微博上，接着还可能是微信平台。毕竟，对于大部分的网络来说，大部分的流量是流向他们的网站的，所以他们不太会在乎其中的外链等等。故而，通常来 说: 不是某某东西突然火了，而是突然没有别的新闻了。通常来说一个好的作法是，试着将你的博客分享到微博上，然后@那些愿意帮你分享的平台。这样，你可以有更 多的阅读、更多的粉丝，当然好的内容是前提。<br>其中还有若干其它的好处:<br>更大的曝光率，会带来更多的机会<br>更有机会参与一些未公开互联网产品的试用<br>各种精美小礼物<br>翻译、出版机会<br>TODO</p>
<p>只需要简单地几步就可以开始提高我们的影响力:<br>在不同的网站上使用一个ID<br>创建一个博客<br>开始创作内容、提交代码、分享<br>持续Impact</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;影响力，让梦想离你更近。&lt;br&gt;试想一下，有一天你开发了一个新的语言。它比现有的某某主流软件，运行效率将提高了50%，开发效率提高了100%。接着，你在github上 release了0.1，但是由于出现某个开发难题，你需要别人的帮助。而这时，你找不到有效的途径去找到那些真正会用它的人。接着出现了一个新的语言可 以达到一样的效果，而这个项目就死于腹中，我记得mruby刚刚只写了一个README.md的时候，就获得了上千个star。&lt;br&gt;如何提高影响力，为自己代言
    
    </summary>
    
      <category term="生活" scheme="http://blog.ypintao.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://blog.ypintao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB索引</title>
    <link href="http://blog.ypintao.com/2015/04/24/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/mongodb%E7%B4%A2%E5%BC%95/"/>
    <id>http://blog.ypintao.com/2015/04/24/技术/数据库/mongodb/mongodb索引/</id>
    <published>2015-04-23T16:00:00.000Z</published>
    <updated>2017-03-21T09:36:06.056Z</updated>
    
    <content type="html"><![CDATA[<p>一、索引基础：<br>    MongoDB的索引几乎与传统的关系型数据库一模一样，这其中也包括一些基本的优化技巧。下面是创建索引的命令：</p>
<pre><code>&gt; db.test.ensureIndex({&quot;username&quot;:1})
可以通过下面的名称查看索引是否已经成功建立：
&gt; db.test.getIndexes()
删除索引的命令是：
&gt; db.test.dropIndex({&quot;username&quot;:1})
在MongoDB中，我们同样可以创建复合索引，如：&lt;!--more--&gt;
-- 数字1表示username键的索引按升序存储，-1表示age键的索引按照降序方式存储。
&gt; db.test.ensureIndex({&quot;username&quot;:1, &quot;age&quot;:-1})
该索引被创建后，基于username和age的查询将会用到该索引，或者是基于username的查询也会用到该索引，但是只是基于age的查询将不 会用到该复合索引。因此可以说，如果想用到复合索引，必须在查询条件中包含复合索引中的前N个索引列。然而如果查询条件中的键值顺序和复合索引中的创建顺 序不一致的话，MongoDB可以智能的帮助我们调整该顺序，以便使复合索引可以为查询所用。如：
&gt; db.test.find({&quot;age&quot;: 30, &quot;username&quot;: &quot;stephen&quot;})
对于上面示例中的查询条件，MongoDB在检索之前将会动态的调整查询条件文档的顺序，以使该查询可以用到刚刚创建的复合索引。
我们可以为内嵌文档创建索引，其规则和普通文档没有任何差别，如：
&gt; db.test.ensureIndex({&quot;comments.date&quot;:1})
对于上面创建的索引，MongoDB都会根据索引的keyname和索引方向为新创建的索引自动分配一个索引名，下面的命令可以在创建索引时为其指定索引名，如：
&gt; db.test.ensureIndex({&quot;username&quot;:1},{&quot;name&quot;:&quot;testindex&quot;})    
随着集合的增长，需要针对查询中大量的排序做索引。如果没有对索引的键调用sort，MongoDB需要将所有数据提取到内存并排序。因此在做无索引排序时，如果数据量过大以致无法在内存中进行排序，此时MongoDB将会报错。
</code></pre><p>二、唯一索引：<br>    在缺省情况下创建的索引均不是唯一索引。下面的示例将创建唯一索引，如：</p>
<pre><code>&gt; db.test.ensureIndex({&quot;userid&quot;:1},{&quot;unique&quot;:true})
如果再次插入userid重复的文档时，MongoDB将报错，以提示插入重复键，如：
&gt; db.test.insert({&quot;userid&quot;:5})
&gt; db.test.insert({&quot;userid&quot;:5})
E11000 duplicate key error index: test.test.$userid_1  dup key: { : 5.0 }    
如果插入的文档中不包含userid键，那么该文档中该键的值为null，如果多次插入类似的文档，MongoDB将会报出同样的错误，如：
&gt; db.test.insert({&quot;userid1&quot;:5})
&gt; db.test.insert({&quot;userid1&quot;:5})
E11000 duplicate key error index: test.test.$userid_1  dup key: { : null }        
如果在创建唯一索引时已经存在了重复项，我们可以通过下面的命令帮助我们在创建唯一索引时消除重复文档，仅保留发现的第一个文档，如：
--先删除刚刚创建的唯一索引。
&gt; db.test.dropIndex({&quot;userid&quot;:1}) 
--插入测试数据，以保证集合中有重复键存在。
&gt; db.test.remove()
&gt; db.test.insert({&quot;userid&quot;:5})
&gt; db.test.insert({&quot;userid&quot;:5})    
--创建唯一索引，并消除重复数据。
&gt; db.test.ensureIndex({&quot;userid&quot;:1},{&quot;unique&quot;:true,&quot;dropDups&quot;:true})    
--查询结果确认，重复的键确实在创建索引时已经被删除。
&gt; db.test.find()
{ &quot;_id&quot; : ObjectId(&quot;4fe823c180144abd15acd52e&quot;), &quot;userid&quot; : 5 }    

我们同样可以创建复合唯一索引，即保证复合键值唯一即可。如：
&gt; db.test.ensureIndex({&quot;userid&quot;:1,&quot;age&quot;:1},{&quot;unique&quot;:true})    
</code></pre><p>三、使用explain：<br>    explain是非常有用的工具，会帮助你获得查询方面诸多有用的信息。只要对游标调用该方法，就可以得到查询细节。explain会返回一个文档，而不是游标本身。如：</p>
<pre><code>&gt; db.test.find().explain()
{
    &quot;cursor&quot; : &quot;BasicCursor&quot;,
    &quot;nscanned&quot; : 1,
    &quot;nscannedObjects&quot; : 1,
    &quot;n&quot; : 1,
    &quot;millis&quot; : 0,
    &quot;nYields&quot; : 0,
    &quot;nChunkSkips&quot; : 0,
    &quot;isMultiKey&quot; : false,
    &quot;indexBounds&quot; : {

    }    
}
explain会返回查询使用的索引情况，耗时和扫描文档数的统计信息。
&quot;cursor&quot;:&quot;BasicCursor&quot;表示没有使用索引。
&quot;nscanned&quot;:1 表示查询了多少个文档。
&quot;n&quot;:1 表示返回的文档数量。
&quot;millis&quot;:0 表示整个查询的耗时。
</code></pre><p>四、索引管理：<br>    system.indexes集合中包含了每个索引的详细信息，因此可以通过下面的命令查询已经存在的索引，如：</p>
<pre><code>&gt; db.system.indexes.find()
如果在为已有数据的文档创建索引时，可以执行下面的命令，以使MongoDB在后台创建索引，这样的创建时就不会阻塞其他操作。但是相比而言，以阻塞方式创建索引，会使整个创建过程效率更高，但是在创建时MongoDB将无法接收其他的操作。
&gt; db.test.ensureIndex({&quot;username&quot;:1},{&quot;background&quot;:true})
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、索引基础：&lt;br&gt;    MongoDB的索引几乎与传统的关系型数据库一模一样，这其中也包括一些基本的优化技巧。下面是创建索引的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; db.test.ensureIndex({&amp;quot;username&amp;quot;:1})
可
    
    </summary>
    
      <category term="数据库" scheme="http://blog.ypintao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="http://blog.ypintao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://blog.ypintao.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 安全和访问权限控制</title>
    <link href="http://blog.ypintao.com/2015/04/22/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/MongoDB%20%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.ypintao.com/2015/04/22/技术/数据库/mongodb/MongoDB 安全和访问权限控制/</id>
    <published>2015-04-21T16:00:00.000Z</published>
    <updated>2017-03-21T09:35:18.076Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的访问控制能够有效保证数据库的安全，访问控制是指绑定Application监听的IP地址，设置监听端口，使用账户和密码登录<br>一，访问控制的参数<a id="more"></a><br>1，绑定IP地址<br>mongod 参数：–bind_ip <ip address=""><br>默认值是所有的IP地址都能访问，该参数指定MongoDB对外提供服务的绑定IP地址，用于监听客户端 Application的连接，客户端只能使用绑定的IP地址才能访问mongod，其他IP地址是无法访问的。<br>2，设置监听端口<br>mongod 参数：–port <port><br>MongoDB 默认监听的端口是27017，该参数显式指定MongoDB实例监听的TCP 端口，只有当客户端Application连接的端口和MongoDB实例监听的端口一致时，才能连接到MongoDB实例。<br>3，启用用户验证<br>mongod 参数：–auth<br>默认值是不需要验证，即 –noauth，该参数启用用户访问权限控制；当mongod 使用该参数启动时，MongoDB会验证客户端连接的账户和密码，以确定其是否有访问的权限。如果认证不通过，那么客户端不能访问MongoDB的数据库。<br>Enables authorization to control user’s access to database resources and operations. When authorization is enabled, MongoDB requires all clients to authenticate themselves first in order to determine the access for the client.<br>4，权限认证<br>mongo 参数：–username <username>, -u <username><br>mongo 参数：–password <password>, -p <password><br>mongo 参数：–authenticationDatabase <dbname>  指定创建User的数据库；在特定的数据库中创建User，该DB就是User的authentication database。<br>在连接mongo时，使用参数 –authenticationDatabase，会认证 -u 和 -p 参数指定的账户和密码。如果没有指定验证数据库，mongo使用连接字符串中指定的DB作为验证数据块。<br>二，基于角色的访问控制（Role-Based Access Control）<br>角色是授予User在指定资源上执行指定操作的权限，MongoDB官方手册对角色的定义是：<br>A role grants privileges to perform the specified actions on resource.<br>MongoDB为了方便管理员管理权限，在DB级别上预先定义了内置角色；如果用户需要对权限进行更为细致的管理，MongoDB允许用户创建自定义的角色，能够在集合级别上控制User能够执行的操作。<br>MongoDB使用角色（Role）授予User访问资源的权限，Role决定User能够访问的数据库资源和执行的操作。一个User能够被授予一个或多个Role，如果User没有被授予Role，那么就没有访问MongoDB系统的权限。<br>A user is granted one or more roles that determine the user’s access to database resources and operations. Outside of role assignments, the user has no access to the system.<br>1，内置角色（Built-In Roles）<br>内置角色是MongoDB预定义的角色，操作的资源是在DB级别上。MongoDB拥有一个SuperUser的角色：root，拥有最大权限，能够在系统的所有资源上执行任意操作。<br>数据库用户角色（Database User Roles）：<br>read：授予User只读数据的权限<br>readWrite：授予User读写数据的权限<br>数据库管理角色（Database Administration Roles）：<br>dbAdmin：在当前dB中执行管理操作<br>dbOwner：在当前DB中执行任意操作<br>userAdmin：在当前DB中管理User<br>备份和还原角色（Backup and Restoration Roles）：<br>backup<br>restore<br>跨库角色（All-Database Roles）：<br>readAnyDatabase：授予在所有数据库上读取数据的权限<br>readWriteAnyDatabase：授予在所有数据库上读写数据的权限<br>userAdminAnyDatabase：授予在所有数据库上管理User的权限<br>dbAdminAnyDatabase：授予管理所有数据库的权限<br>集群管理角色（Cluster Administration Roles）：<br>clusterAdmin：授予管理集群的最高权限<br>clusterManager：授予管理和监控集群的权限，A user with this role can access the config and local databases, which are used in sharding and replication, respectively.<br>clusterMonitor：授予监控集群的权限，对监控工具具有readonly的权限<br>hostManager：管理Server<br>2，用户自定义的角色（User-Defined Roles）<br>内置角色只能控制User在DB级别上执行的操作，管理员可以创建自定义角色，控制用户在集合级别（Collection-Level）上执行的操作，即，控制User在当前DB的特定集合上执行特定的操作。<br>在创建角色时，必须明确Role的四个特性：<br>Scope：角色作用的范围，创建在Admin中的角色，能够在其他DB中使用；在其他DB中创建的角色，只能在当前DB中使用；<br>Resource：角色控制的资源，表示授予在该资源上执行特定操作的权限；<br>Privilege Actions：定义了User能够在资源上执行的操作，系统定义Action是：Privilege Actions；<br>Inherit：角色能够继承其他角色权限<br>2.1 角色作用的范围（Scope）<br>在admin 数据库中创建的角色，Scope是全局的，能够在admin，其他DB和集群中使用，并且能够继承其他DB的Role；而在非admin中创建的角色，Scope是当前数据库，只能在当前DB中使用，只能继承当前数据库的角色。<br>A role created in the admin database can include privileges that apply to the admin database, other databases or to the cluster resource, and can inherit from roles in other databases as well as the admin database. Except for roles created in the admin database, a role can only include privileges that apply to its database and can only inherit from other roles in its database.<br>2.2 权限的操作（Privilege actions）<br>MongoDB的权限包由：资源（Resource）和操作（Action）两部分组成，Privilege Actions 定义User能够在资源上执行的操作，例如：MongoDB在文档级别（Document-Level）上执行的读写操作（Query and Write Actions）列表是：<br>find<br>insert<br>remove<br>update<br>3，创建角色<br>使用db.CreateRole()在当前DB中创建角色，创建的语法示例如下：<br>复制代码<br>use admin<br>db.createRole(<br>   {<br>     role: “new_role”,<br>     privileges: [<br>       { resource: { cluster: true }, actions: [ “addShard” ] },<br>       { resource: { db: “config”, collection: “” }, actions: [ “find”, “update”, “insert”, “remove” ] },<br>       { resource: { db: “users”, collection: “usersCollection” }, actions: [ “update”, “insert”, “remove” ] },<br>       { resource: { db: “”, collection: “” }, actions: [ “find” ] }<br>     ],<br>     roles: [<br>       { role: “read”, db: “admin” }<br>     ]<br>   },<br>   { w: “majority” , wtimeout: 5000 }<br>)<br>复制代码<br>在roles数组中，指定被继承的role，即，新建的new_role从roles数组中继承权限：<br>如果被继承的role在当前DB中，定义的格式是：roles:[“role”]；<br>如果被继承的role不在当前DB中，需要使用doc，指定该role所在的DB，定义的格式是：roles:[{role:”role_name”, db:”db_name”}]；<br>4，自定义角色管理函数<br>db.createRole() ：Creates a role and specifies its privileges.<br>db.updateRole() ：Updates a user-defined role.<br>db.dropRole() ：Deletes a user-defined role.<br>db.dropAllRoles() ：Deletes all user-defined roles associated with a database.<br>db.grantPrivilegesToRole() ：Assigns privileges to a user-defined role.<br>db.revokePrivilegesFromRole() ：Removes the specified privileges from a user-defined role.<br>db.grantRolesToRole() ：Specifies roles from which a user-defined role inherits privileges.<br>db.revokeRolesFromRole() ：Removes inherited roles from a role.<br>db.getRole() ：Returns information for the specified role.<br>db.getRoles() ：Returns information for all the user-defined roles in a database.<br>三，管理用户和权限<br>1，创建用户<br>复制代码<br>use db_name<br>db.createUser(<br>{<br>    user: “user_name”,<br>    pwd: “user_pwd”,<br>    roles: [   { role: “clusterAdmin”, db: “admin” },<br>               { role: “readAnyDatabase”, db: “admin” },<br>               “readWrite”<br>           ]<br>}<br>)<br>复制代码<br>为新建的User，授予一个或多个角色，通过roles数组来实现：<br>如果role存在于当前DB中，roles的格式：roles:[“role”]；<br>如果role不存在于当前DB中，roles的格式：roles:[Role:”role_name”, db:”db_name”]；<br>2，权限认证（Authenticate）<br>mongo连接到mongod，有两种权限认证的方式：<br>在连接时认证用户访问的权限，mongo 使用参数 –authenticationDatabase <dbname> 指定认证数据库；<br>在连接后，认证用户访问的权限，mongo 没有使用参数 –authenticationDatabase <dbname>，在连接到mongod之后，切换到验证数据库（authentication database）中，使用db.auth() 验证User是否有权限访问当前数据库；<br>use db_name<br>db.auth(“user_name”, “user_pwd” )<br>3，用户管理函数<br>db.auth() ：Authenticates a user to a database.<br>db.createUser() ：Creates a new user.<br>db.updateUser() ：Updates user data.<br>db.changeUserPassword() ：Changes an existing user’s password.<br>db.dropAllUsers() ：Deletes all users associated with a database.<br>db.dropUser() ：Removes a single user.<br>db.grantRolesToUser() ：Grants a role and its privileges to a user.<br>db.revokeRolesFromUser() ：Removes a role from a user.<br>db.getUser() ：Returns information about the specified user.<br>db.getUsers() ：Returns information about all users associated with a database.</dbname></dbname></dbname></password></password></username></username></port></ip></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB的访问控制能够有效保证数据库的安全，访问控制是指绑定Application监听的IP地址，设置监听端口，使用账户和密码登录&lt;br&gt;一，访问控制的参数
    
    </summary>
    
      <category term="数据库" scheme="http://blog.ypintao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mongodb" scheme="http://blog.ypintao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/"/>
    
    
      <category term="mongodb" scheme="http://blog.ypintao.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>git入门</title>
    <link href="http://blog.ypintao.com/2015/04/01/%E6%8A%80%E6%9C%AF/web%E5%89%8D%E7%AB%AF/gulp/gulp%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.ypintao.com/2015/04/01/技术/web前端/gulp/gulp入门/</id>
    <published>2015-03-31T16:00:00.000Z</published>
    <updated>2017-03-22T06:42:15.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="你仅仅需要知道的5个gulp命令"><a href="#你仅仅需要知道的5个gulp命令" class="headerlink" title="你仅仅需要知道的5个gulp命令"></a>你仅仅需要知道的5个gulp命令<a id="more"></a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">gulp.task(name, fn)这个你应经见过了</div><div class="line"></div><div class="line">gulp.run(tasks...)尽可能多的并行运行多个task</div><div class="line"></div><div class="line">gulp.watch(glob, fn)当glob内容发生改变时，执行fn</div><div class="line"></div><div class="line">gulp.src(glob)返回一个可读的stream</div><div class="line"></div><div class="line">gulp.dest(glob)返回一个可写的stream</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;你仅仅需要知道的5个gulp命令&quot;&gt;&lt;a href=&quot;#你仅仅需要知道的5个gulp命令&quot; class=&quot;headerlink&quot; title=&quot;你仅仅需要知道的5个gulp命令&quot;&gt;&lt;/a&gt;你仅仅需要知道的5个gulp命令
    
    </summary>
    
      <category term="web前端" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="gulp" scheme="http://blog.ypintao.com/categories/web%E5%89%8D%E7%AB%AF/gulp/"/>
    
    
      <category term="gulp" scheme="http://blog.ypintao.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>forever用途</title>
    <link href="http://blog.ypintao.com/2015/03/24/%E6%8A%80%E6%9C%AF/Linux/node%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/forever%E7%94%A8%E9%80%94/"/>
    <id>http://blog.ypintao.com/2015/03/24/技术/Linux/node开发工具/forever用途/</id>
    <published>2015-03-23T16:00:00.000Z</published>
    <updated>2017-03-21T10:31:55.963Z</updated>
    
    <content type="html"><![CDATA[<p>Github地址：<a href="https://github.com/nodejitsu/forever" target="_blank" rel="external">https://github.com/nodejitsu/forever</a><br>forever用途<br>forever的用途就是帮我们更好的管理我们node App服务，本质上就是在forever进程之下，创建一个node app的子进程。<br>比如，你有一个基于express的或者其他的一些个应用那么，它将会很方便你更新和操作你的服务，并且保证你服务能持续运行。<a id="more"></a><br>更好的一点就是每次更改文件，它都可以帮你自动重启服务而不需要手动重启。<br>安装forever<br>复制代码 代码如下:</p>
<p>// 记得加-g，forever要求安装到全局环境下</p>
<blockquote>
<p>sudo npm install forever -g</p>
</blockquote>
<p>forever使用说明</p>
<p>启动相关</p>
<p>复制代码 代码如下:</p>
<p>// 1. 简单的启动</p>
<blockquote>
<p>forever start app.js<br>// 2. 指定forever信息输出文件，当然，默认它会放到~/.forever/forever.log<br>forever start -l forever.log app.js<br>// 3. 指定app.js中的日志信息和错误日志输出文件，<br>//  -o 就是console.log输出的信息，-e 就是console.error输出的信息<br>forever start -o out.log -e err.log app.js<br>// 4. 追加日志，forever默认是不能覆盖上次的启动日志，<br>//  所以如果第二次启动不加-a，则会不让运行<br>forever start -l forever.log -a app.js<br>// 5. 监听当前文件夹下的所有文件改动<br>forever start -w app.js<br>文件改动监听并自动重启</p>
</blockquote>
<p>复制代码 代码如下:</p>
<p>// 1. 监听当前文件夹下的所有文件改动（不太建议这样）</p>
<blockquote>
<p>forever start -w app.js</p>
</blockquote>
<p>显示所有运行的服务<br>复制代码 代码如下:</p>
<blockquote>
<p>forever list</p>
</blockquote>
<p>停止操作<br>复制代码 代码如下:<br>// 1. 停止所有运行的node App</p>
<blockquote>
<p>forever stopall<br>// 2. 停止其中一个node App<br>forever stop app.js<br>// 当然还可以这样<br>// forever list 找到对应的id，然后：<br>forever stop [id]<br>重启操作<br>重启操作跟停止操作保持一致。<br>复制代码 代码如下:<br>// 1. 启动所有<br>forever restartall<br>开发和线上建议配置<br>复制代码 代码如下:</p>
</blockquote>
<p>// 开发环境下</p>
<blockquote>
<p>NODE_ENV=development forever start -l forever.log -e err.log -a app.js<br>// 线上环境下<br>NODE_ENV=production forever start -l ~/.forever/forever.log -e ~/.forever/err.log -w -a app.js</p>
</blockquote>
<p>上面加上NODE_ENV为了让app.js辨认当前是什么环境用的。不加它可能就不知道哦？<br>一些注意点<br>有可能你需要使用unix下的crontab（定时任务）<br>这个时候需要注意配置好环境变量。<br>复制代码 代码如下:</p>
<blockquote>
<p>SHELL=/bin/sh<br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/nodejitsu/forever&quot;&gt;https://github.com/nodejitsu/forever&lt;/a&gt;&lt;br&gt;forever用途&lt;br&gt;forever的用途就是帮我们更好的管理我们node App服务，本质上就是在forever进程之下，创建一个node app的子进程。&lt;br&gt;比如，你有一个基于express的或者其他的一些个应用那么，它将会很方便你更新和操作你的服务，并且保证你服务能持续运行。
    
    </summary>
    
      <category term="Linux" scheme="http://blog.ypintao.com/categories/Linux/"/>
    
      <category term="node开发工具" scheme="http://blog.ypintao.com/categories/Linux/node%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="node开发工具" scheme="http://blog.ypintao.com/tags/node%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
